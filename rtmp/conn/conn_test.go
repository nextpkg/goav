package conn

import (
	"net"
	"sync"
	"testing"
	"time"

	"github.com/nextpkg/goav/packet"
	"github.com/nextpkg/goav/chunk"
	"github.com/nextpkg/goav/rtmp/comm"
	"github.com/stretchr/testify/assert"
)

var flvIFrame = []byte{
	0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xd3, 0x65, 0x88, 0x80, 0x80, 0x03, 0x3f, 0xfe,
	0xf5, 0xf8, 0x45, 0x4f, 0x32, 0xcb, 0x1b, 0xb4,
	0x20, 0x3f, 0x85, 0x4d, 0xd6, 0x9b, 0xc2, 0xca,
	0x91, 0xb2, 0xbc, 0xe1, 0xfb, 0x35, 0x27, 0x44,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x50, 0x99, 0x98,
	0x41, 0xd1, 0xaf, 0xd3, 0x24, 0xae, 0xa0, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x0f, 0x60, 0x00, 0x11,
	0xc0, 0x00, 0x1b, 0x40, 0x00, 0x4e, 0x40, 0x01,
	0x1f, 0x00, 0x03, 0xb8, 0x00, 0x10, 0x80, 0x00,
	0x59, 0x00, 0x02, 0x38, 0x00, 0x0b, 0xe0, 0x00,
	0x5e, 0x00, 0x02, 0x20, 0x00, 0x11, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x40, 0x41,
}

var avcIFrame = []byte{
	0x0, 0x0, 0x0, 0xd3, 0x65, 0x88, 0x80, 0x80,
	0x3, 0x3f, 0xfe, 0xf5, 0xf8, 0x45, 0x4f, 0x32,
	0xcb, 0x1b, 0xb4, 0x20, 0x3f, 0x85, 0x4d, 0xd6,
	0x9b, 0xc2, 0xca, 0x91, 0xb2, 0xbc, 0xe1, 0xfb,
	0x35, 0x27, 0x44, 0x0, 0x0, 0x3, 0x0, 0x0,
	0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x50, 0x99, 0x98, 0x41, 0xd1, 0xaf, 0xd3, 0x24,
	0xae, 0xa0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xf,
	0x60, 0x0, 0x11, 0xc0, 0x0, 0x1b, 0x40, 0x0,
	0x4e, 0x40, 0x1, 0x1f, 0x0, 0x3, 0xb8, 0x0,
	0x10, 0x80, 0x0, 0x59, 0x0, 0x2, 0x38, 0x0,
	0xb, 0xe0, 0x0, 0x5e, 0x0, 0x2, 0x20, 0x0,
	0x11, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3,
	0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0,
	0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3,
	0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0,
	0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3,
	0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0,
	0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3,
	0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0,
	0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0,
	0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3,
	0x0, 0x0, 0x3, 0x0, 0x0, 0x40, 0x41,
}

// mockWriter implements the Writer interface for testing
type mockWriter struct {
	conn *chunk.Conn
}

func (m *mockWriter) Read(cs *chunk.ChunkStream) error {
	return m.conn.Read(cs)
}

func (m *mockWriter) Write(cs *chunk.ChunkStream) error {
	return m.conn.Write(cs)
}

func (m *mockWriter) Flush() error {
	return m.conn.Flush()
}

func (m *mockWriter) Close() error {
	return m.conn.Close()
}

func (m *mockWriter) GetInfo() (app, instance string) {
	return "test_app", "test_instance"
}

func (m *mockWriter) GetPublish() *comm.PublishInfo {
	return &comm.PublishInfo{}
}

func (m *mockWriter) GetConnect() *comm.ConnectInfo {
	return &comm.ConnectInfo{}
}

func TestWriter_Write(t *testing.T) {
	at := assert.New(t)

	i, o := net.Pipe()
	mockConn := &mockWriter{
		conn: chunk.NewConn(i, chunk.DefaultOption),
	}

	w := NewWriter(mockConn)

	// 视频数据
	p := &packet.Packet{
		Type:     packet.PktVideo,
		StreamID: 1,
		Data:     flvIFrame,
	}
	err := w.Write(p)
	at.Nil(err)

	// 音频数据
	p = &packet.Packet{
		Type:     packet.PktAudio,
		StreamID: 1,
		Data:     avcIFrame,
	}
	err = w.Write(p)
	at.Nil(err)

	go func() {
		time.Sleep(50 * time.Millisecond)
		at.Nil(mockConn.Flush())
	}()

	buf := make([]byte, 1024)
	n, err := o.Read(buf)
	at.Nil(err)
	at.Equal(461, n)
}

// mockReader implements the Reader interface for testing
type mockReader struct {
	conn     *chunk.Conn
	streamID uint32
}

func (m *mockReader) Read(cs *chunk.ChunkStream) error {
	return m.conn.Read(cs)
}

func (m *mockReader) Write(cs *chunk.ChunkStream) error {
	return m.conn.Write(cs)
}

func (m *mockReader) Flush() error {
	return m.conn.Flush()
}

func (m *mockReader) Close() error {
	return m.conn.Close()
}

func (m *mockReader) GetInfo() (app, instance string) {
	return "test_app", "test_instance"
}

func (m *mockReader) GetPublish() *comm.PublishInfo {
	return &comm.PublishInfo{}
}

func (m *mockReader) GetConnect() *comm.ConnectInfo {
	return &comm.ConnectInfo{}
}

func TestReader_Read(t *testing.T) {
	at := assert.New(t)

	i, o := net.Pipe()
	mockConn := &mockReader{
		conn:     chunk.NewConn(i, chunk.DefaultOption),
		streamID: 1,
	}

	cs := &chunk.ChunkStream{
		Length:   220,
		StreamID: 1,
		TypeID:   9,
		Data:     flvIFrame,
	}
	at.Nil(mockConn.Write(cs))

	go func() {
		at.Nil(mockConn.Flush())
	}()

	buf := make([]byte, 1024)
	n, err := o.Read(buf)
	at.Nil(err)
	at.Equal(233, n)

	data := buf[:n]

	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()
		n, err = o.Write(data)
		at.Nil(err)
		at.Equal(233, n)
	}()

	r := NewReader(mockConn)
	p := &packet.Packet{}
	at.Nil(r.Read(p))

	wg.Wait()
}
